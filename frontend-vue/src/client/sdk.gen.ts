// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { CreateAnalysisApiAnalysesPostData, CreateAnalysisApiAnalysesPostErrors, CreateAnalysisApiAnalysesPostResponses, DeleteAnalysisApiAnalysesAnalysisIdDeleteData, DeleteAnalysisApiAnalysesAnalysisIdDeleteErrors, DeleteAnalysisApiAnalysesAnalysisIdDeleteResponses, GetAnalysisDetailApiAnalysesAnalysisIdGetData, GetAnalysisDetailApiAnalysesAnalysisIdGetErrors, GetAnalysisDetailApiAnalysesAnalysisIdGetResponses, ListAnalysisApiAnalysesGetData, ListAnalysisApiAnalysesGetErrors, ListAnalysisApiAnalysesGetResponses, ReadRootGetData, ReadRootGetResponses, UpdateAnalysisApiAnalysesAnalysisIdPatchData, UpdateAnalysisApiAnalysesAnalysisIdPatchErrors, UpdateAnalysisApiAnalysesAnalysisIdPatchResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List Analysis
 *
 * Retrieves a paginated list of analysis summaries.
 *
 * Args:
 * page (int): The current page number (starts at 1).
 * per_page (int): The number of items to return per page.
 *
 * Returns:
 * PaginatedResponse[AnalysisList]: A dictionary containing pagination metadata and the list of elements.
 *
 * Raises:
 * HTTPException(500): If an internal database error occurs.
 */
export const listAnalysisApiAnalysesGet = <ThrowOnError extends boolean = false>(options?: Options<ListAnalysisApiAnalysesGetData, ThrowOnError>) => (options?.client ?? client).get<ListAnalysisApiAnalysesGetResponses, ListAnalysisApiAnalysesGetErrors, ThrowOnError>({
    responseType: 'json',
    url: '/api/analyses',
    ...options
});

/**
 * Create Analysis
 *
 * Creates a new analysis record along with its nested code classes.
 *
 * Args:
 * analysis_create (AnalysisCreate): The payload containing name, origin, and classes.
 *
 * Returns:
 * Optional[Analysis]: The created analysis object with its generated ID.
 *
 * Raises:
 * HTTPException(422): If there are duplicate classes in the request.
 * HTTPException(500): If the creation fails due to server error.
 */
export const createAnalysisApiAnalysesPost = <ThrowOnError extends boolean = false>(options: Options<CreateAnalysisApiAnalysesPostData, ThrowOnError>) => (options.client ?? client).post<CreateAnalysisApiAnalysesPostResponses, CreateAnalysisApiAnalysesPostErrors, ThrowOnError>({
    responseType: 'json',
    url: '/api/analyses',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete Analysis
 *
 * Deletes an analysis and all associated classes.
 *
 * Args:
 * analysis_id (int): The ID of the analysis to delete.
 *
 * Raises:
 * HTTPException(404): If the analysis does not exist.
 * HTTPException(500): If the deletion fails.
 */
export const deleteAnalysisApiAnalysesAnalysisIdDelete = <ThrowOnError extends boolean = false>(options: Options<DeleteAnalysisApiAnalysesAnalysisIdDeleteData, ThrowOnError>) => (options.client ?? client).delete<DeleteAnalysisApiAnalysesAnalysisIdDeleteResponses, DeleteAnalysisApiAnalysesAnalysisIdDeleteErrors, ThrowOnError>({ url: '/api/analyses/{analysis_id}', ...options });

/**
 * Get Analysis Detail
 *
 * Fetches the full details of a specific analysis, including nested classes.
 *
 * Args:
 * analysis_id (int): The unique identifier of the analysis.
 *
 * Returns:
 * Analysis: The complete analysis object with hydrated class levels.
 *
 * Raises:
 * HTTPException(404): If the analysis does not exist.
 * HTTPException(500): If an internal server error occurs.
 */
export const getAnalysisDetailApiAnalysesAnalysisIdGet = <ThrowOnError extends boolean = false>(options: Options<GetAnalysisDetailApiAnalysesAnalysisIdGetData, ThrowOnError>) => (options.client ?? client).get<GetAnalysisDetailApiAnalysesAnalysisIdGetResponses, GetAnalysisDetailApiAnalysesAnalysisIdGetErrors, ThrowOnError>({
    responseType: 'json',
    url: '/api/analyses/{analysis_id}',
    ...options
});

/**
 * Update Analysis
 *
 * Updates an existing analysis.
 *
 * If 'classes' are provided, the existing classes are replaced entirely (Delete & Insert).
 * If 'classes' is an empty list, all classes for this analysis are removed.
 *
 * Args:
 * analysis_id (int): The ID of the analysis to update.
 * analysis_update (AnalysisUpdate): The fields to update (name, origin, classes).
 *
 * Returns:
 * Optional[Analysis]: The updated analysis object, or None if not found.
 *
 * Raises:
 * HTTPException(404): If the analysis ID does not exist.
 * HTTPException(422): If the new class list contains duplicates.
 * HTTPException(500): If the update fails due to server error.
 */
export const updateAnalysisApiAnalysesAnalysisIdPatch = <ThrowOnError extends boolean = false>(options: Options<UpdateAnalysisApiAnalysesAnalysisIdPatchData, ThrowOnError>) => (options.client ?? client).patch<UpdateAnalysisApiAnalysesAnalysisIdPatchResponses, UpdateAnalysisApiAnalysesAnalysisIdPatchErrors, ThrowOnError>({
    responseType: 'json',
    url: '/api/analyses/{analysis_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Read Root
 */
export const readRootGet = <ThrowOnError extends boolean = false>(options?: Options<ReadRootGetData, ThrowOnError>) => (options?.client ?? client).get<ReadRootGetResponses, unknown, ThrowOnError>({
    responseType: 'json',
    url: '/',
    ...options
});
